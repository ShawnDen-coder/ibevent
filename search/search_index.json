{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ibevent","text":"<p>A library for simplifying event listening for Interactive Brokers (IBKR).</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install ibevent\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>To get started with <code>ibevent</code>, follow these steps:</p> <ol> <li>Connect to Interactive Brokers.</li> <li>Create a contract for the asset you want to trade.</li> <li>Register event handlers to listen for market data updates.</li> </ol>"},{"location":"#example","title":"Example","text":"<pre><code>from ib_async import IB\nfrom ibevent.events import IBEventType\nfrom ib_async.contract import Forex\n\n# Create IB connection\nib = IB()\nib.connect('127.0.0.1', 7497, clientId=1)\n\n# Create USD/JPY contract\nusd_jpy = Forex('USDJPY')\n\n# Register bar update handler\n@ib.events.register(\n    IBEventType.BAR_UPDATE,\n    bind_to=ib.reqRealTimeBars(\n        usd_jpy,\n        barSize=5,\n        whatToShow='MIDPOINT',\n        useRTH=True\n    )\n)\ndef handle_bar(ib, bars, has_new_bar):\n    if has_new_bar:\n        print(bars[-1])\n\n# Run until interrupted\nib.run()\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Event-driven framework for handling IB API events.</li> <li>Support for asynchronous event handling.</li> <li>Priority-based event handlers for multiple data streams.</li> </ul>"},{"location":"#ibeventtype-enumeration","title":"IBEventType Enumeration","text":"<p>The <code>IBEventType</code> enumeration defines all supported IB API event types. Each event type corresponds to a specific event in the IB API that can be subscribed to and handled.</p>"},{"location":"#attributes","title":"Attributes:","text":"<ul> <li><code>BAR_UPDATE</code>: Real-time bar data update event.</li> <li><code>ERROR</code>: Error event from IB API.</li> <li><code>CONNECTED</code>: Connection established event.</li> <li><code>DISCONNECTED</code>: Connection lost event.</li> <li>(Other attributes as needed)</li> </ul>"},{"location":"#example-usage","title":"Example Usage:","text":"<pre><code>from ibevent.events import IBEventType\n\n# Example of using IBEventType\nevent_type = IBEventType.BAR_UPDATE\nprint(event_type)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>ibevent<ul> <li>events</li> <li>hooks</li> </ul> </li> </ul>"},{"location":"reference/ibevent/","title":"Index","text":""},{"location":"reference/ibevent/#ibevent","title":"ibevent","text":"<p>Interactive Brokers Event System.</p> <p>This module provides an event-driven framework for handling Interactive Brokers (IB) API events. It allows you to easily subscribe to market data and handle events with priority-based handlers.</p> <p>Key components: - IBEventType: Enumeration of supported IB API event types. - BaseEventRegistry: Base class for event registration and handling. - IBEventRegistry: IB-specific event registry with automatic event binding. - patch_ib: Function to add event system support to the IB class.</p> Example <p>Basic usage with real-time bar data:</p> <p>from ib_async import IB from ibevent.events import IBEventType from ib_async.contract import Forex</p> <p>This module is designed to be extensible and easy to use, allowing developers to quickly set up event-driven systems for trading applications using the Interactive Brokers API.</p> Note <p>This module requires the ib_async library and an active connection to Interactive Brokers TWS or IB Gateway.</p> See Also <p>ib_async: https://github.com/erdewit/ib_async</p>"},{"location":"reference/ibevent/#ibevent--connect-to-ib","title":"Connect to IB","text":"<p>ib = IB() ib.connect('127.0.0.1', 7497, clientId=1)</p>"},{"location":"reference/ibevent/#ibevent--create-contract","title":"Create contract","text":"<p>usd_jpy = Forex('USDJPY')</p>"},{"location":"reference/ibevent/#ibevent--register-event-handler-with-data-binding","title":"Register event handler with data binding","text":"<p>@ib.events.register( ...     IBEventType.BAR_UPDATE, ...     bind_to=ib.reqRealTimeBars( ...         usd_jpy, ...         barSize=5, ...         whatToShow='MIDPOINT' ...     ) ... ) def handle_bar(ib, bars, has_new_bar): ...     if has_new_bar: ...         print(bars[-1])</p>"},{"location":"reference/ibevent/#ibevent--run-event-loop","title":"Run event loop","text":"<p>ib.run()</p>"},{"location":"reference/ibevent/events/","title":"events","text":""},{"location":"reference/ibevent/events/#ibevent.events","title":"ibevent.events","text":"<p>Interactive Brokers Event System.</p> <p>This module provides an event-driven framework for handling Interactive Brokers (IB) API events. It allows you to easily subscribe to market data and handle events with priority-based handlers.</p> Example <p>Basic usage with real-time bar data:</p> <p>from ib_async import IB from ibevent.events import IBEventType from ib_async.contract import Forex</p>"},{"location":"reference/ibevent/events/#ibevent.events--connect-to-ib","title":"Connect to IB","text":"<p>ib = IB() ib.connect('127.0.0.1', 7497, clientId=1)</p>"},{"location":"reference/ibevent/events/#ibevent.events--create-contract","title":"Create contract    &gt;&gt;&gt;","text":"<p>usd_jpy = Forex('USDJPY')</p>"},{"location":"reference/ibevent/events/#ibevent.events--register-event-handler-with-data-binding","title":"Register event handler with data binding","text":"<p>@ib.events.register( ...     IBEventType.BAR_UPDATE, ...     bind_to=ib.reqRealTimeBars( ...         usd_jpy, ...         barSize=5, ...         whatToShow='MIDPOINT' ...     ) ... ) def handle_bar(ib, bars, has_new_bar): ...     if has_new_bar: ...         print(bars[-1])</p>"},{"location":"reference/ibevent/events/#ibevent.events--run-event-loop","title":"Run event loop","text":"<p>ib.run()</p>"},{"location":"reference/ibevent/events/#ibevent.events.BaseEventRegistry","title":"BaseEventRegistry","text":"<pre><code>BaseEventRegistry()\n</code></pre> <p>event registration base class.</p> <p>Initialize the event registry.</p> Source code in <code>ibevent/events.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the event registry.\"\"\"\n    self._handlers: Dict[Any, List[Tuple[int, Callable]]] = {}\n</code></pre>"},{"location":"reference/ibevent/events/#ibevent.events.BaseEventRegistry.register","title":"register","text":"<pre><code>register(event_type: IBEventType, *, bind_to: Any = None, priority: int = 0)\n</code></pre> <p>Register event handler.</p> <p>This decorator registers a function as a handler for a specific event type. Handlers can be either synchronous or asynchronous functions.</p> PARAMETER DESCRIPTION <code>event_type</code> <p>The type of event to handle.</p> <p> TYPE: <code>IBEventType</code> </p> <code>bind_to</code> <p>Optional data source to bind to (e.g., ib.reqRealTimeBars(...)).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> <code>priority</code> <p>Handler priority. Higher numbers execute first. Defaults to 0.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <p>A decorator function that registers the handler.</p> Example <p>@registry.register(IBEventType.BAR_UPDATE, priority=10) def handle_bar(ib, bars, has_new_bar): ...     if has_new_bar: ...         print(bars[-1])</p> Source code in <code>ibevent/events.py</code> <pre><code>def register(self, event_type: IBEventType, *, bind_to: Any = None, priority: int = 0):\n    \"\"\"Register event handler.\n\n    This decorator registers a function as a handler for a specific event type.\n    Handlers can be either synchronous or asynchronous functions.\n\n    Args:\n        event_type: The type of event to handle.\n        bind_to: Optional data source to bind to (e.g., ib.reqRealTimeBars(...)).\n        priority: Handler priority. Higher numbers execute first. Defaults to 0.\n\n    Returns:\n        A decorator function that registers the handler.\n\n    Example:\n        &gt;&gt;&gt; @registry.register(IBEventType.BAR_UPDATE, priority=10)\n        &gt;&gt;&gt; def handle_bar(ib, bars, has_new_bar):\n        ...     if has_new_bar:\n        ...         print(bars[-1])\n    \"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            return func(*args, **kwargs)\n\n        if event_type not in self._handlers:\n            self._handlers[event_type] = []\n        self._handlers[event_type].append((priority, wrapper))\n        self._handlers[event_type].sort(key=lambda x: x[0], reverse=True)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/ibevent/events/#ibevent.events.IBEventRegistry","title":"IBEventRegistry","text":"<pre><code>IBEventRegistry(ib)\n</code></pre> <p>               Bases: <code>BaseEventRegistry</code></p> <p>A registry for Interactive Brokers (IB) API events.</p> <p>This class extends BaseEventRegistry to provide specific functionality for handling IB API events. It sets up handlers for various IB API events and manages their execution.</p> ATTRIBUTE DESCRIPTION <code>ib</code> <p>An instance of the IB API client.</p> <p> </p> Example <p>from ib_async import IB ib = IB() registry = IBEventRegistry(ib) @registry.register(IBEventType.BAR_UPDATE, priority=10) ... def handle_bar(ib, bars, has_new_bar): ...     if has_new_bar: ...         print(bars[-1]) ib.connect('127.0.0.1', 7497, clientId=1) ib.run()</p> <p>Initialize the IB event registry.</p> PARAMETER DESCRIPTION <code>ib</code> <p>The IB API instance to register events with.</p> <p> </p> Source code in <code>ibevent/events.py</code> <pre><code>def __init__(self, ib):\n    \"\"\"Initialize the IB event registry.\n\n    Args:\n        ib: The IB API instance to register events with.\n    \"\"\"\n    super().__init__()\n    self.ib = ib\n    self._setup_ib_handlers()\n</code></pre>"},{"location":"reference/ibevent/events/#ibevent.events.IBEventRegistry._handle_event","title":"_handle_event","text":"<pre><code>_handle_event(event_type: IBEventType, *args)\n</code></pre> <p>Handle an IB API event.</p> <p>This method is called when an IB API event occurs. It dispatches the event to all registered handlers in priority order.</p> PARAMETER DESCRIPTION <code>event_type</code> <p>The type of event that occurred.</p> <p> TYPE: <code>IBEventType</code> </p> <code>*args</code> <p>Arguments from the IB API event.</p> <p> DEFAULT: <code>()</code> </p> Source code in <code>ibevent/events.py</code> <pre><code>def _handle_event(self, event_type: IBEventType, *args):\n    \"\"\"Handle an IB API event.\n\n    This method is called when an IB API event occurs. It dispatches the event\n    to all registered handlers in priority order.\n\n    Args:\n        event_type: The type of event that occurred.\n        *args: Arguments from the IB API event.\n    \"\"\"\n    if event_type in self._handlers:\n        for _, handler in self._handlers[event_type]:\n            try:\n                result = handler(self.ib, *args)\n                if asyncio.iscoroutine(result):\n                    asyncio.create_task(result)\n            except Exception as e:\n                logger.error(f\"Error in event handler: {e}\")\n</code></pre>"},{"location":"reference/ibevent/events/#ibevent.events.IBEventRegistry._setup_ib_handlers","title":"_setup_ib_handlers","text":"<pre><code>_setup_ib_handlers()\n</code></pre> <p>Set up handlers for IB API events.</p> <p>This method is called during initialization to set up the connection between IB API events and our event handling system.</p> Source code in <code>ibevent/events.py</code> <pre><code>def _setup_ib_handlers(self):\n    \"\"\"Set up handlers for IB API events.\n\n    This method is called during initialization to set up the connection\n    between IB API events and our event handling system.\n    \"\"\"\n    for event_type in IBEventType:\n        if hasattr(self.ib, event_type.value):\n            event = getattr(self.ib, event_type.value)\n            event += lambda *args, et=event_type: self._handle_event(et, *args)\n</code></pre>"},{"location":"reference/ibevent/events/#ibevent.events.IBEventType","title":"IBEventType","text":"<p>               Bases: <code>Enum</code></p> <p>Interactive Brokers event type enumeration.</p> <p>This enum defines all supported IB API event types. Each event type corresponds to a specific event in the IB API that can be subscribed to and handled.</p> ATTRIBUTE DESCRIPTION <code>BAR_UPDATE</code> <p>Real-time bar data update event.</p> <p> </p> <code>ERROR</code> <p>Error event from IB API.</p> <p> </p> <code>CONNECTED</code> <p>Connection established event.</p> <p> </p> <code>DISCONNECTED</code> <p>Connection lost event.</p> <p> </p>"},{"location":"reference/ibevent/events/#ibevent.events.patch_ib","title":"patch_ib","text":"<pre><code>patch_ib()\n</code></pre> <p>Patch the IB class to add event system support.</p> <p>This function adds an 'events' property to the IB class, which provides access to the event system. The event registry is created lazily when first accessed.</p> Source code in <code>ibevent/events.py</code> <pre><code>def patch_ib():\n    \"\"\"Patch the IB class to add event system support.\n\n    This function adds an 'events' property to the IB class, which provides\n    access to the event system. The event registry is created lazily when first accessed.\n    \"\"\"\n    from ib_async import IB\n\n    def _get_events(self):\n        if not hasattr(self, \"_events\"):\n            self._events = IBEventRegistry(self)\n        return self._events\n\n    IB.events = property(_get_events)\n</code></pre>"},{"location":"reference/ibevent/hooks/","title":"hooks","text":""},{"location":"reference/ibevent/hooks/#ibevent.hooks","title":"ibevent.hooks","text":"<p>Hook system for extending IBEvent functionality.</p> <p>This module provides a flexible hook system that allows users to extend and customize the behavior of the IBEvent framework without modifying its core code. It includes utilities for loading, managing, and executing hook functions at various points in the IBEvent lifecycle.</p> <p>Key components: - HookContext: A context object for sharing data between hooks. - load_hook: Function to dynamically load a hook from a file. - execute_hooks: Function to execute a list of hooks with a given context.</p> <p>Typical usage example:</p> <pre><code>from ibevent.hooks import HookContext, load_hook, execute_hooks\n\n# Create a hook context\ncontext = HookContext()\n\n# Define hook files\nhook_files = ['/path/to/hook1.py', '/path/to/hook2.py']\n\n# Load and execute hooks\nexecute_hooks(hook_files, context)\n\n# Access shared data\nresult = context.data.get('some_key')\n</code></pre> <p>Hook files should define a 'run' function that takes a HookContext object:</p> <pre><code># Example hook file: hook1.py\ndef run(context):\n    # Perform some action\n    context.data['some_key'] = 'some_value'\n</code></pre> <p>This module is designed to be extensible, allowing users to add custom functionality to various parts of the IBEvent system without altering the core implementation.</p>"},{"location":"reference/ibevent/hooks/#ibevent.hooks.HookContext","title":"HookContext","text":"<pre><code>HookContext()\n</code></pre> <p>               Bases: <code>object</code></p> <p>Context object for sharing data between hooks.</p> <p>This class provides a simple data sharing mechanism between hooks through its data dictionary attribute. Hooks can store and retrieve data using this context object.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>Dictionary for storing shared data between hooks.</p> <p> TYPE: <code>dict</code> </p> <p>Initialize an empty HookContext.</p> <p>The data dictionary is initialized as an empty dict and can be populated by hooks during execution.</p> Source code in <code>ibevent/hooks.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize an empty HookContext.\n\n    The data dictionary is initialized as an empty dict and can be\n    populated by hooks during execution.\n    \"\"\"\n    self.data = {}\n</code></pre>"},{"location":"reference/ibevent/hooks/#ibevent.hooks.execute_hooks","title":"execute_hooks","text":"<pre><code>execute_hooks(hook_files, context)\n</code></pre> <p>Execute a list of hook modules with the given context.</p> <p>This function processes a list of hook files, loading and executing each one in sequence. Each hook is executed in isolation, meaning that if one hook fails, it won't prevent other hooks from executing.</p> <p>Each hook module is expected to contain a single function named <code>run</code> which takes a HookContext as its argument. The context object allows hooks to share data between themselves.</p> PARAMETER DESCRIPTION <code>hook_files</code> <p>List of absolute paths to the hook modules.</p> <p> TYPE: <code>list[str]</code> </p> <code>context</code> <p>The context object to pass to the hooks.</p> <p> TYPE: <code>HookContext</code> </p> Example <p>context = HookContext() hook_files = ['/path/to/pre_launch.py', '/path/to/setup_env.py'] execute_hooks(hook_files, context)</p> Note <ul> <li>Hooks are executed in the order they appear in hook_files</li> <li>Each hook's errors are caught and logged, not propagated</li> <li>Non-existent hook files are silently skipped</li> </ul> Source code in <code>ibevent/hooks.py</code> <pre><code>def execute_hooks(hook_files, context):\n    \"\"\"Execute a list of hook modules with the given context.\n\n    This function processes a list of hook files, loading and executing each one\n    in sequence. Each hook is executed in isolation, meaning that if one hook\n    fails, it won't prevent other hooks from executing.\n\n    Each hook module is expected to contain a single function named `run`\n    which takes a HookContext as its argument. The context object allows\n    hooks to share data between themselves.\n\n    Args:\n        hook_files (list[str]): List of absolute paths to the hook modules.\n        context (HookContext): The context object to pass to the hooks.\n\n    Example:\n        &gt;&gt;&gt; context = HookContext()\n        &gt;&gt;&gt; hook_files = ['/path/to/pre_launch.py', '/path/to/setup_env.py']\n        &gt;&gt;&gt; execute_hooks(hook_files, context)\n\n    Note:\n        - Hooks are executed in the order they appear in hook_files\n        - Each hook's errors are caught and logged, not propagated\n        - Non-existent hook files are silently skipped\n    \"\"\"\n    for hook_file in hook_files:\n        if os.path.exists(hook_file):\n            hook = load_hook(hook_file)\n            if hook:\n                try:\n                    hook(context)\n                except Exception as e:\n                    logger.error(\"Error executing hook %s: %s\", hook_file, str(e))\n</code></pre>"},{"location":"reference/ibevent/hooks/#ibevent.hooks.load_hook","title":"load_hook","text":"<pre><code>load_hook(file_path)\n</code></pre> <p>Load a hook module from a file path and return its run function.</p> <p>This function dynamically loads a Python module from the given file path and extracts its 'run' function. The module should define a function named 'run' that takes a HookContext object as its argument.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Absolute path to the hook module file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>callable</code> <p>The run function from the module, or None if loading fails.</p> Example <p>hook = load_hook('/path/to/hook.py') if hook: ...     hook(context)</p> Source code in <code>ibevent/hooks.py</code> <pre><code>def load_hook(file_path):\n    \"\"\"Load a hook module from a file path and return its run function.\n\n    This function dynamically loads a Python module from the given file path\n    and extracts its 'run' function. The module should define a function\n    named 'run' that takes a HookContext object as its argument.\n\n    Args:\n        file_path (str): Absolute path to the hook module file.\n\n    Returns:\n        callable: The run function from the module, or None if loading fails.\n\n    Example:\n        &gt;&gt;&gt; hook = load_hook('/path/to/hook.py')\n        &gt;&gt;&gt; if hook:\n        ...     hook(context)\n    \"\"\"\n    try:\n        spec = importlib.util.spec_from_file_location(\"hook\", file_path)\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n        return module.run\n    except Exception as e:\n        logger.error(\"Failed to load hook from %s: %s\", file_path, str(e))\n        return None\n</code></pre>"}]}